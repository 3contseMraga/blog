<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<script src="./27. 移除元素/index.js"></script>
<body>
  <script>
    function Graph() {
      this.topPointArr = []    // 存储顶点，笔者认为图的顶点是不会重复的
      this.edgeMap = new Map() // 存储边
    }

    // 往图里添加顶点
    Graph.prototype.addTopPoint = function (point) {
      this.topPointArr.push(point)
      this.edgeMap.set(point, [])
    }

    // 往指定的点添加相邻的点
    Graph.prototype.addEdge = function (point1, point2) {
      this.edgeMap.get(point1).push(point2)
      this.edgeMap.get(point2).push(point1) // 这里默认没有方向，所以两个点互相指向
    }

    // 将图给打印出来
    Graph.prototype.log = function () {
      let str = ''
      let neighbour
      for (let i of this.topPointArr) {
        str += i + ' -> '
        neighbour = this.edgeMap.get(i).join(' ')
        str += neighbour + '\n'
      }
      return str
    }

    Graph.prototype.bfs = function (v, callback) {
      const obj = {}

      for (let i of this.topPointArr) { // 初始化颜色
        obj[i] = 'white'
      }

      const queue = new Queue()
      obj[v] = 'gray'

      queue.push(v)

      let shiftQueue, neighbour

      while (!queue.isEmpty()) {
        shiftQueue = queue.shift()
        neighbour = this.edgeMap.get(shiftQueue)

        for (let i of neighbour) {
          if (obj[i] === 'white') {
            obj[i] = 'gray'
            queue.push(i)
          }
        }

        if (callback) {
          callback(shiftQueue)
        }
      }
    }

    function Queue() {
      this.items = []
    }

    Queue.prototype.push = function (item) {
      this.items.push(item)
    }

    Queue.prototype.shift = function () {
      return this.items.shift()
    }

    Queue.prototype.isEmpty = function () {
      return this.items.length === 0
    }

    Queue.prototype.size = function () {
      return this.items.length
    }

    Queue.prototype.clear = function () {
      this.items = []
    }

    var graph = new Graph()
    var topArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    for (let i of topArr) {
      graph.addTopPoint(i)
    }

    graph.addEdge('A', 'B')
    graph.addEdge('A', 'C')
    graph.addEdge('A', 'D')
    graph.addEdge('B', 'E')
    graph.addEdge('B', 'F')
    graph.addEdge('C', 'D')
    graph.addEdge('C', 'G')
    graph.addEdge('D', 'G')
    graph.addEdge('D', 'H')
    graph.addEdge('E', 'I')

    // graph.bfs('A', (shiftQueue) => {
    //   console.log(shiftQueue)
    // })
  </script>
</body>
</html>