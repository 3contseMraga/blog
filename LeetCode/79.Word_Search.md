### 79.Word Search

Given an `m x n` board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The `same letter cell may not be used more than once`.

Example 1:

![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
```

Example 2:

![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
```

Example 3:

![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
```

Constraints:

* m === board.length
* n === board[i].length
* 1 <= m, n <= 200
* 1 <= word.length <= 103
* board and word consists only of lowercase and uppercase English letters.

### Analyze

```js
A B C E
S F C S
A D E E
```

二维数组找路径适合用回溯法。每个节点根据`下、右、上、左`四个方向回溯查找元素。

拿 `ABCCED` 作为例子, 括号中为淘汰的值。

A(S) -> B(F) -> C -> C -> E(空、E、C) -> D

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let x = 0; x < board.length; x++) {
    for (let y = 0; y < board[x].length; y++) {
      if (word[0] === border) {
        return backTrace(board, word, 1, x, y)
      }
    }
  }
  return false
};

/** start: means start of word */
var backTrace = (board, word, start, x, y) => {
  if (start === word.length - 1 && (
    word[start] === board[x][y + 1] || word[start] === board[x + 1][y] || word[start] === board[x][y - 1] || word[start] === board[x - 1][y]
  )) {
    return true
  }

  if (word[start] === board[x][y + 1]) {
    return backTrace(board, word, start + 1, x, y + 1)
  } else if (word[start] === board[x + 1][y]) {
    return backTrace(board, word, start + 1, x + 1, y)
  } else if (word[start] === board[x][y - 1]) {
    return backTrace(board, word, start + 1, x, y - 1)
  } else if (word[start] === board[x - 1][y]) {
    return backTrace(board, word, start + 1, x - 1, y)
  } else {
    return false
  }
}
```

// todo: used value