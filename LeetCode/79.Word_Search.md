### 79.Word Search

Given an `m x n` board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The `same letter cell may not be used more than once`.

Example 1:

![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
```

Example 2:

![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
```

Example 3:

![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```js
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
```

Constraints:

* m === board.length
* n === board[i].length
* 1 <= m, n <= 200
* 1 <= word.length <= 103
* board and word consists only of lowercase and uppercase English letters.

### Analyze

```js
     y列
x行   A  B  C  E
      S  F  C  S
      A  D  E  E
```

二维数组找路径适合用回溯法。每个节点根据`下、右、上、左`四个方向回溯查找元素。

拿 `ABCCED` 作为例子, 括号中为淘汰的值。

A(S) -> B(F) -> C -> C -> E(空、E、C) -> D

```js
     y列
x行   C  A  A
      A  A  A
      B  C  D
```

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let x = 0; x < board.length; x++) {
    for (let y = 0; y < board[x].length; y++) {
      if (word.length === 1 && word[0] === board[x][y]) {
        return true
      }
      if (word[0] === board[x][y]) {
        const ifValid = backTrace(board, word, 1, x, y, [])
        if (ifValid) return ifValid
      }
    }
  }
  return false
};

/** start: means start of word */
var backTrace = (board, word, start, x, y, used) => {
  debugger
  used.push(`${x},${y}`)
  const useBottom = used.indexOf(`${x},${y + 1}`) === -1 && word[start] === (board[x] && board[x][y + 1])
  const useRight = used.indexOf(`${x + 1},${y}`) === -1 && word[start] === (board[x + 1] && board[x + 1][y])
  const useTop = used.indexOf(`${x},${y - 1}`) === -1 && word[start] === (board[x] && board[x][y - 1])
  const useLeft = used.indexOf(`${x - 1},${y}`) === -1 && word[start] === (board[x - 1] && board[x - 1][y])
  if (start === word.length - 1 && (useBottom || useRight || useTop || useLeft)) {
    return true
  }

  if (useBottom) {
    const tag = backTrace(board, word, start + 1, x, y + 1, used)
    used.pop()
    return tag
  } else if (useRight) {
    const tag = backTrace(board, word, start + 1, x + 1, y, used)
    used.pop()
    return tag
  } else if (useTop) {
    const tag = backTrace(board, word, start + 1, x, y - 1, used)
    used.pop()
    return tag
  } else if (useLeft) {
    const tag = backTrace(board, word, start + 1, x - 1, y, used)
    used.pop()
    return tag
  } else {
    used.pop()
    return false
  }
}
```

```js
输入：
[["C","A","A"],["A","A","A"],["B","C","D"]]
"AAB"
输出：
false
预期：
true
```