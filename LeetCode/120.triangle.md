### 120. Triangle

Given a triangle array, return the `minimum path sum` from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either `index i` or `index i + 1` on the next row.

Example 1:

```js
Input: triangle = [[2], [3,4], [6,5,7], [4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

Example 2:

```js
Input: triangle = [[-10]]
Output: -10
```

* Constraints:
  * 1 <= triangle.length <= 200
  * triangle[0].length == 1
  * triangle[i].length == triangle[i - 1].length + 1
  * -104 <= triangle[i][j] <= 104
 
Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?

### Analyze

```js
0 0 0 0
  1 1 1
    2 2
      3

0 0 0 0
0 0 0 1
0 0 1 1
0 0 1 2
0 1 1 1
0 1 1 2
0 1 2 2
0 1 2 3

0 0 0
  1 1
    2

0 0 0
0 0 1
0 1 1
0 1 2
```

递归: 根据题意当前值的下标为 m, 则其上一个数的下标为 m - 1 或者 m。

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
  const result = getSmaller(triangle, 0, 0, 0)
  return result
}

// m: witch row
// n: witch column
// curMin: current min value
var getSmaller = function(triangle, m, n, curMin) {
  if (m === triangle.length) {

  }

  const value1 = getSmaller(m + 1, n)
  const value2 = getSmaller(m + 1, n + 1)

  return value1 < value2 ? value1 : value2
}
```

todo:

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
  for (let m = 0; m < triangle.length; m++) {

  }
  return result
}
```

```js
输入：
[[-1],[2,3],[1,-1,-3]]
输出：
0
预期：
-1
```
