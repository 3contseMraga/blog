### 字典

类似于集合，字典也是一种无重复元素，无顺序的数据结构。

区别在于在集合中，我们以 [值， 值] 的形式存储；在字典中，我们以 [键，值] 的形式存储；集合的知识点可以阅读 [集合](https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/集合.md)

ES6 引入的 Map 就是字典的数据类型。

#### 简易版 Map 实现

我们来动手实现一个简易版的 Map，它拥有的 api 如下：

```js
set(key, value)

delete(key)

get(key)

has(key)

clear()

values()

size
```

```js
function Map() {
  this.items = {}
  this.size = 0
}

Map.prototype.has = function(key) {
  for (let i in this.items) {
    if (this.items.hasOwnProperty(i)) {
      return true
    }
  }
  return false
}

Map.prototype.delete = function(key) {
  if (this.has(key)) {
    delete(this.items[key])
    this.size--
    return true
  }
  return false
}

Map.prototype.set = function(key, value) {
  this.items[key] = value // 这里是不严谨的实现
  this.size++
}

Map.prototype.get = function(key) {
  return this.items[key]
}

Map.prototype.clear = function() {
  this.items = {}
  this.size = 0
}

Map.prototype.values = function() {
  const arr = []
  Object.keys(this.items).forEach(r => {
    arr.push(this.items[r])
  })
  return arr
}
```

### 哈希表

哈希表算是一种特殊的字典。它在实际的键值和存入的哈希值之间存在一层映射。如下例子：

![](http://oqhtscus0.bkt.clouddn.com/963b04e081590a419bfc97c30d915a01.jpg-300)

上图中通过哈希函数将键值转换成哈希值，然后再将哈希值指向具体的值。接着我们来构造 HashTable 类，代码如下：

```js
function HashTable() {
  this.items = {}
}

// 哈希算法
function keyToHash(key) {
  let hash = 0
  for (let i = 0; i < key.length; i++) {
    hash += key.charCodeAt(i)
  }
  hash = hash % 37 // 为了避免 hash 的值过大
  return hash
}

HashTable.prototype.put = function(key, value) {
  const hash = keyToHash(key)
  this.items[hash] = value
}

HashTable.prototype.get = function(key) {
  return this.items[keyToHash(key)]
}

HashTable.prototype.remove = function(key) {
  delete(this.items[keyToHash(key)])
}
```

测试一下

```js
var test = new HashTable()
test.put('ab', 'ab@gmail.com')
test.put('cd', 'cd@gmail.com')
test.put('ef', 'ef@gmail.com')

test.get('cd') // "cd@gmail.com"
test.remove('cd')
test.get('cd') // undefined
```

但是这样子实现的哈希表有一个问题，比如进行如下调用就会产生冲突：

```js
test.put('ab', 'ab@gmail.com')
test.put('ba', 'ba@gmail.com') // ab 和 ba 的哈希值相同，后者会把前者覆盖
```

接着我们来尝试解决该问题

#### 链表法

顾名思义，这个方法就是在每个哈希值上引人链表。如下图所示：

![](http://oqhtscus0.bkt.clouddn.com/8f944bba4c158e6c212f81ad941f263e.jpg-200)

对之前 put、get、remove 方法做如下修改，其中使用到的链表的代码参考之前的 [链表](https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/链表.md#链表的实现)

```js
function HashTable() {
  this.items = {}
}

function keyToHash(key) {
  let hash = 0
  for (let i = 0; i < key.length; i++) {
    hash += key.charCodeAt(i)
  }
  hash = hash % 37
  return hash
}

// 存入链表的值
function Node(key, value) {
  this.key = key
  this.value = value
}

// 添加接口
HashTable.prototype.put = function(key, value) {
  const hash = keyToHash(key)
  if (!this.items[hash]) {
    this.items[hash] = new LinkedList() // 这里将之前实现的链表拿来使用
  }
  this.items[hash].append(new Node(key, value))
}

HashTable.prototype.has = function (hash) {
  if (this.items.hasOwnProperty(hash)) {
    return true
  }
  return false
}

// 获取接口
HashTable.prototype.get = function(key) {
  const hash = keyToHash(key)
  if (this.has(hash)) {
    let current = this.items[hash].getHead()
    while (current) {
      if (current.element.key === key) {
        return current.element.value
      }
      current = current.next
    }
  }
  return undefined
}

// 移除接口
HashTable.prototype.remove = function(key) {
  const hash = keyToHash(key)
  if (this.has(hash)) {
    let current = this.items[hash].getHead()
    while (current) {
      if (current.element.key === key) {
        this.items[hash].remove(current.element)
        return true
      }
      current = current.next
    }
    return false
  }
  return false
}
```

接着来测试下完成的哈希表，测试用例如下：

```js
var test = new HashTable()
test.put('ab', 'ab@gmail.com')
test.put('ba', 'ba@gmail.com')
test.put('cd', 'cd@gmail.com')

test.get('ab') // ab@gmail.com
test.get('ba') // ba@gmail.com
test.get('cd') // cd@gmail.com

test.remove('ba')
test.get('ba') // undefined
```