### 图

图是一种非线性数据结构。它的表示有以下几种：

* 邻接矩阵

邻接矩阵是表示图的常用方法，用二维数组来表示，数组的每个下标对应每个点。当两个点有连线则二维数组的值为 1，否则二维数组的值为 0。但是这种表示方法会照成存储空间的浪费（因存在大量 0）。

![](http://oqhtscus0.bkt.clouddn.com/79f5520b6028aa16491649c846430b04.jpg-300)

* 邻接表

如下图：左侧为存储的顶点，右侧为与之想对应的点，后文会采用这种方式实现图。

![](http://oqhtscus0.bkt.clouddn.com/0a1d5ab4a96e83dca8c7aafc948e2f4b.jpg-300)

* 关联矩阵

行表示点，列表示边。

![](http://oqhtscus0.bkt.clouddn.com/48a4bf7ee32827ad4d9016f24a8ffca5.jpg-300)

```js
function Graph() {
  this.topPointArr = []    // 存储顶点，笔者认为图的顶点是不会重复的
  this.edgeMap = new Map() // 存储边
}

// 往图里添加顶点
Graph.prototype.addTopPoint = function(point) {
  this.topPointArr.push(point)
  this.edgeMap.set(point, [])
}

// 往指定的点添加相邻的点
Graph.prototype.addEdge = function(point1, point2) {
  this.edgeMap.get(point1).push(point2)
  this.edgeMap.get(point2).push(point1) // 这里默认没有方向，所以两个点互相指向
}

// 将图给打印出来
Graph.prototype.log = function() {
  let str = ''
  let neighbour
  for (let i of this.topPointArr) {
    str += i + ' -> '
    neighbour = this.edgeMap.get(i).join(' ')
    str += neighbour + '\n'
  }
  return str
}
```

按之前邻接表的图示，跑如下测试用例：

```js
var graph = new Graph()
var topArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
for (let i of topArr) {
  graph.addTopPoint(i)
}

graph.addEdge('A', 'B')
graph.addEdge('A', 'C')
graph.addEdge('A', 'D')
graph.addEdge('B', 'E')
graph.addEdge('B', 'F')
graph.addEdge('C', 'D')
graph.addEdge('C', 'G')
graph.addEdge('D', 'G')
graph.addEdge('D', 'H')
graph.addEdge('E', 'I')
```

使用自定义打印函数 graph.log()，打印结果如下，结果符合预期

```
A -> B C D
B -> A E F
C -> A D G
D -> A C G H
E -> B I
F -> B
G -> C D
H -> D
I -> E
```

### 图的遍历

~~后文总结两种遍历~~

#### 广度优先遍历(BFS)

顾名思义，广度优先即横向优先，示意图如下：

![](http://oqhtscus0.bkt.clouddn.com/4547193af1645f33359e875559092c6b.jpg-200)

核心要点：先入队列的先遍历。思路如下：(标白：未发现；标灰：已找寻；))

* 创建队列 u，将标灰的顶点插入队列

* 若队列 u 不为空

  * 从队列取出值 v

  * 将 v 的相邻节点标灰并插入队列 u

代码中用到队列相关的方法可参考 [队列](https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/队列.md)

<details>
  <summary>Queue实现</summary>

    function Queue() {
      this.items = []
    }

    Queue.prototype.push = function(item) {
      this.items.push(item)
    }

    Queue.prototype.shift = function() {
      return this.items.shift()
    }

    Queue.prototype.isEmpty = function() {
      return this.items.length === 0
    }

    Queue.prototype.size = function() {
      return this.items.length
    }

    Queue.prototype.clear = function() {
      this.items = []
    }

</details>

```js
Graph.prototype.bfs = function(v, callback) {
  const obj = {}

  for (let i of this.topPointArr) { // 初始化颜色
    obj[i] = 'white'
  }

  const queue = new Queue()
  obj[v] = 'gray'

  queue.push(v)

  let shiftQueue, neighbour

  while (!queue.isEmpty()) {
    shiftQueue = queue.shift()
    neighbour = this.edgeMap.get(shiftQueue)

    for (let i of neighbour) {
      if (obj[i] === 'white') {
        obj[i] = 'gray'
        queue.push(i)
      }
    }

    if (callback) {
      callback(shiftQueue)
    }
  }
}
```

检验完成的 bfs 函数，进行如下调用，

```js
graph.bfs('A', (shiftQueue) => {
  console.log(shiftQueue)
})
```

打印结果为 A B C D E F G H I，符合预期。