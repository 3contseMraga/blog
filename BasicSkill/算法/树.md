### 树

![](http://oqhtscus0.bkt.clouddn.com/c3bc86f87907fedaeba86b0f5b96a71a.jpg-300)

这幅图中有如下概念：

* 根节点：一棵树最顶部的节点

* 内部节点：在它上面还有其它内部节点或者叶节点的节点

* 叶节点：处于一棵树根部的节点

* 子树：由树中的内部节点和叶节点组成

此外这棵树是二叉树（树中最多有两个分支），同时它也是二叉搜索树（左侧子节点的数字小于父节点，右侧子节点的数字大于父节点）

### 二叉搜索树的实现

```js
function BinarySearchTree() {
  function Node(key) {
    this.key = key
    this.left = null
    this.right = null
  }

  let root = null

  // 插入元素
  // 实现思路：至顶向下插入，先判断顶点是否为空；顶点为空则直接在该处插入，若不为空，则通过比较顶点的 key 和插入元素的 key 判断该插入到顶点的左侧还是右侧，后面进行如上递归
  this.insert = function(key) {
    const node = new Node(key)
    if (root === null) {
      root = node
    } else {
      insertNode(root, node)
    }
    function insertNode(parent, node) {
      if (parent.key > node.key) {
        if (parent.left === null) {
          parent.left = node
        } else {
          insertNode(parent.left, node)
        }
      } else if (parent.key < node.key) {
        if (parent.right === null) {
          parent.right = node
        } else {
          insertNode(parent.right, node)
        }
      }
    }
  }

  // 中序遍历
  this.inOrderTraverse = function(cb) {
    inOrderTraverse(root, cb)
    function inOrderTraverse(node, cb) {
      if (node) {
        inOrderTraverse(node.left, cb)
        cb(node.key)
        inOrderTraverse(node.right, cb)
      }
    }
  }

  // 先序遍历
  this.preOrderTraverse = function(cb) {
    preOrderTraverse(root, cb)
    function preOrderTraverse(node, cb) {
      if (node) {
        cb(node.key)
        preOrderTraverse(node.left, cb)
        preOrderTraverse(node.right, cb)
      }
    }
  }

  // 后序遍历
  this.postOrderTraverse = function(cb) {
    postOrderTraverse(root, cb)
    function postOrderTraverse(node, cb) {
      if (node) {
        postOrderTraverse(node.left, cb)
        postOrderTraverse(node.right, cb)
        cb(node.key)
      }
    }
  }

  this.search = function(key) {

  }

  this.max = function() {

  }

  this.min = function() {

  }

  this.remove = function(key) {

  }
}
```

### 三种遍历方式的不同

* 中序遍历：可用于二叉搜索树的排序

![](http://oqhtscus0.bkt.clouddn.com/ceeb68f801304f9910073708dd35ae64.jpg-300)

* 先序遍历：可用于打印结构化的文档

![](http://oqhtscus0.bkt.clouddn.com/65df3e9414f594107d95127f8ab5a9a1.jpg-300)

* 后序遍历：可用于查看文件夹目录

![](http://oqhtscus0.bkt.clouddn.com/212607e3b24b52c0df959902ed8e4b1f.jpg-300)

三种遍历的实现方式大同小异，可在上面代码中观察到实现的差异。

```js
// 测试用例
var tree = new BinarySearchTree()
tree.insert(11)
tree.insert(7)
tree.insert(15)
tree.insert(5)
tree.insert(3)
tree.insert(9)
tree.insert(8)
tree.insert(10)
tree.insert(13)
tree.insert(12)
tree.insert(14)
tree.insert(20)
tree.insert(18)
tree.insert(25)
tree.insert(6)

var cb = (key) => console.log(key)

tree.inOrderTraverse(cb)   // 中序遍历: 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25
tree.preOrderTraverse(cb)  // 先序遍历：11 7 5 3 6 9 8 10 15 13 12 14 20 18 25
tree.postOrderTraverse(cb) // 后序遍历：3 6 5 8 10 9 7 12 14 13 18 25 20 15 11
```